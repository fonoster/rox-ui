!function(){var e=("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).parcelRequirecdaa;e.register("1xuKZ",(function(n,o){var t,r,i,a;t=n.exports,r="resetPropWarnings",i=()=>c,Object.defineProperty(t,r,{get:i,set:a,enumerable:!0,configurable:!0});var p=e("bGkYf");e("8peQR");var s={};function c(){s={}}function l(e){return e.type===p.Fragment?"Fragment":"function"==typeof e.type?e.type.displayName||e.type.name:"string"==typeof e.type?e.type:"#text"}var f=[],u=[];function d(){return f.length>0?f[f.length-1]:null}var y=!1;function _(e){return"function"==typeof e.type&&e.type!=p.Fragment}function h(e){for(var n=[e],o=e;null!=o.__o;)n.push(o.__o),o=o.__o;return n.reduce((function(e,n){e+="  in "+l(n);var o=n.__source;return o?e+=" (at "+o.fileName+":"+o.lineNumber+")":y||(y=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),e+"\n"}),"")}var m="function"==typeof WeakMap,v=p.Component.prototype.setState;p.Component.prototype.setState=function(e,n){return null==this.__v?null==this.state&&console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n'+h(d())):null==this.__P&&console.warn('Can\'t call "this.setState" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+h(this.__v)),v.call(this,e,n)};var b=p.Component.prototype.forceUpdate;function w(e){var n=e.props,o=l(e),t="";for(var r in n)if(n.hasOwnProperty(r)&&"children"!==r){var i=n[r];"function"==typeof i&&(i="function "+(i.displayName||i.name)+"() {}"),i=Object(i)!==i||i.toString?i+"":Object.prototype.toString.call(i),t+=" "+r+"="+JSON.stringify(i)}var a=n.children;return"<"+o+t+(a&&a.length?">..</"+o+">":" />")}p.Component.prototype.forceUpdate=function(e){return null==this.__v?console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n'+h(d())):null==this.__P&&console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+h(this.__v)),b.call(this,e)},function(){!function(){var e=p.options.__b,n=p.options.diffed,o=p.options.__,t=p.options.vnode,r=p.options.__r;p.options.diffed=function(e){_(e)&&u.pop(),f.pop(),n&&n(e)},p.options.__b=function(n){_(n)&&f.push(n),e&&e(n)},p.options.__=function(e,n){u=[],o&&o(e,n)},p.options.vnode=function(e){e.__o=u.length>0?u[u.length-1]:null,t&&t(e)},p.options.__r=function(e){_(e)&&u.push(e),r&&r(e)}}();var e=!1,n=p.options.__b,o=p.options.diffed,t=p.options.vnode,r=p.options.__e,i=p.options.__,a=p.options.__h,c=m?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,d=[];p.options.__e=function(e,n,o){if(n&&n.__c&&"function"==typeof e.then){var t=e;e=new Error("Missing Suspense. The throwing component was: "+l(n));for(var i=n;i;i=i.__)if(i.__c&&i.__c.__c){e=t;break}if(e instanceof Error)throw e}try{r(e,n,o),"function"!=typeof e.then&&setTimeout((function(){throw e}))}catch(e){throw e}},p.options.__=function(e,n){if(!n)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var o;switch(n.nodeType){case 1:case 11:case 9:o=!0;break;default:o=!1}if(!o){var t=l(e);throw new Error("Expected a valid HTML node as a second argument to render.\tReceived "+n+" instead: render(<"+t+" />, "+n+");")}i&&i(e,n)},p.options.__b=function(o){var t,r,i,a,p=o.type,f=function e(n){return n?"function"==typeof n.type?e(n.__):n:{}}(o.__);if(e=!0,void 0===p)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+w(o)+"\n\n"+h(o));if(null!=p&&"object"==typeof p){if(void 0!==p.__k&&void 0!==p.__e)throw new Error("Invalid type passed to createElement(): "+p+"\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My"+l(o)+" = "+w(p)+";\n  let vnode = <My"+l(o)+" />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n"+h(o));throw new Error("Invalid type passed to createElement(): "+(Array.isArray(p)?"array":p))}if("thead"!==p&&"tfoot"!==p&&"tbody"!==p||"table"===f.type?"tr"===p&&"thead"!==f.type&&"tfoot"!==f.type&&"tbody"!==f.type&&"table"!==f.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+w(o)+"\n\n"+h(o)):"td"===p&&"tr"!==f.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+w(o)+"\n\n"+h(o)):"th"===p&&"tr"!==f.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+w(o)+"\n\n"+h(o)):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+w(o)+"\n\n"+h(o)),void 0!==o.ref&&"function"!=typeof o.ref&&"object"!=typeof o.ref&&!("$$typeof"in o))throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got ['+typeof o.ref+"] instead\n"+w(o)+"\n\n"+h(o));if("string"==typeof o.type)for(var u in o.props)if("o"===u[0]&&"n"===u[1]&&"function"!=typeof o.props[u]&&null!=o.props[u])throw new Error("Component's \""+u+'" property should be a function, but got ['+typeof o.props[u]+"] instead\n"+w(o)+"\n\n"+h(o));if("function"==typeof o.type&&o.type.propTypes){if("Lazy"===o.type.displayName&&c&&!c.lazyPropTypes.has(o.type)){var d="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{var y=o.type();c.lazyPropTypes.set(o.type,!0),console.warn(d+"Component wrapped in lazy() is "+l(y))}catch(t){console.warn(d+"We will log the wrapped component's name once it is loaded.")}}var _=o.props;o.type.__f&&delete(_=function(e,n){for(var o in n)e[o]=n[o];return e}({},_)).ref,t=o.type.propTypes,r=_,i=l(o),a=function(){return h(o)},Object.keys(t).forEach((function(e){var n;try{n=t[e](r,e,i,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(e){n=e}!n||n.message in s||(s[n.message]=!0,console.error("Failed prop type: "+n.message+(a&&"\n"+a()||"")))}))}n&&n(o)},p.options.__h=function(n,o,t){if(!n||!e)throw new Error("Hook can only be invoked from render methods.");a&&a(n,o,t)};var y=function(e,n){return{get:function(){var o="get"+e+n;d&&d.indexOf(o)<0&&(d.push(o),console.warn("getting vnode."+e+" is deprecated, "+n))},set:function(){var o="set"+e+n;d&&d.indexOf(o)<0&&(d.push(o),console.warn("setting vnode."+e+" is not allowed, "+n))}}},v={nodeName:y("nodeName","use vnode.type"),attributes:y("attributes","use vnode.props"),children:y("children","use vnode.props.children")},b=Object.create({},v);p.options.vnode=function(e){var n=e.props;if(null!==e.type&&null!=n&&("__source"in n||"__self"in n)){var o=e.props={};for(var r in n){var i=n[r];"__source"===r?e.__source=i:"__self"===r?e.__self=i:o[r]=i}}e.__proto__=b,t&&t(e)},p.options.diffed=function(n){if(n.__k&&n.__k.forEach((function(e){if(e&&void 0===e.type){delete e.__,delete e.__b;var o=Object.keys(e).join(",");throw new Error("Objects are not valid as a child. Encountered an object with the keys {"+o+"}.\n\n"+h(n))}})),e=!1,o&&o(n),null!=n.__k)for(var t=[],r=0;r<n.__k.length;r++){var i=n.__k[r];if(i&&null!=i.key){var a=i.key;if(-1!==t.indexOf(a)){console.error('Following component has two or more children with the same key attribute: "'+a+'". This may cause glitches and misbehavior in rendering process. Component: \n\n'+w(n)+"\n\n"+h(n));break}t.push(a)}}}}()})),e.register("8peQR",(function(n,o){var t=e("bGkYf");"undefined"!=typeof window&&window.__PREACT_DEVTOOLS__&&window.__PREACT_DEVTOOLS__.attachPreact("10.5.14",t.options,{Fragment:t.Fragment,Component:t.Component})}))}();